import

# Enter your code here. Read input from STDIN. Print output to STDOUT

#Join Palindromes

#Construct a trie of all words
# For each word,  construct words that when appended form a palindrome
# Look for those words/patterns  in the trie .

'''
The basic idea is to check each word for prefixes (and suffixes) that are themselves palindromes.
 If you find a prefix that is a valid palindrome,
then the suffix reversed can be paired with the word in order to make a palindrome. It’s better explained with an example.

words = ["bot", "t", "to"]
Starting with the string “bot”. We start checking all prefixes. If "", "b", "bo", "bot" are themselves palindromes.
The empty string and “b” are palindromes. We work with the corresponding suffixes (“bot”, “ot”)
and check to see if their reverses (“tob”, “to”) are present in our initial word list.
If so (like the word to"to"), we have found a valid pairing where the reversed suffix can be
prepended to the current word in order to form “to” + “bot” = “tobot”.

You can do the same thing by checking all suffixes to see if they are palindromes.
If so, then finding all reversed prefixes will give you the words that can be appended to the current word to form a palindrome.

The process is then repeated for every word in the list. Note that when considering suffixes,
we explicitly leave out the empty string to avoid counting duplicates.
That is, if a palindrome can be created by appending an entire other word to the current word,

 then we will already consider such a palindrome when considering the empty string as prefix for the other word.

#given a set of words
#Form the Prefix tree for all the words give

#Take each word,Get all the prefixes of the word
#Get the list of palindromes of the prefixes,get the corresponding suffixes of the palindrome prefexis
#(reverse them ) and look if they exist in the Trie, if they exist, you found a palindrome pair for the word.

#Repeat the same for suffixes as well.
#Empty string which is also treated specially , we will need to look for the entire word reversed if is exists and
also appended to them if they have a palindromstring prepended or appended , then we need to look for that pattern as well

'''
# some_file.py
import TrieNode

class TrieNode:
    def __init__(self,val):
        self.val = val
        self.children = {}
        self.word_ending = None

#Time Complexity is O(N*M) with M
class Trie:
    def __init__(self):
        self.rootNode = TrieNode(" ")

    def addword(self,w1):
        currentNode = self.rootNode
        for ch in w1:
            if ch not in currentNode.children.keys():
                #char is not  present, create a newNode
                currentNode.children[ch] = TrieNode(ch)
            currentNode = currentNode.children[ch]
        currentNode.word_ending = True

    def searchword(self,w1):
        currentNode = self.rootNode
        for ch in w1:
            if ch not in currentNode.children.keys():
                #char is not  present, return False
                return False
            currentNode = currentNode.children[ch]
        return(currentNode.word_ending)

    def searchPrefix(self,prefix):
        currentNode = self.rootNode
        for ch in len(prefix):
            if ch not in currentNode.children.keys():
                #Prefix is not present , return [""]
                return []
            currentNode = currentNode.children[ch]
        word = list(prefix)
        wordList = []
        self._collect_all(self,currentNode,word,wordList)
        return wordList

    def _collect_all(self,Node,word,wList):
        currentNode = Node
        if currentNode.word_ending :
            wList.append("".join(word))
        if currentNode == None:
            return
        for ch in currentNode.children.keys():
            word.append(ch)
            _collect_all(self,currentNode[ch],word,wList)
        word.pop()

    def searchPattern(self,pattern):
        # Go to the indxof the
        indx = 0
        output=[]
        word = []
        node = self.rootNode
        _searchPattern(self,node,word,indx,pattern,output)

    def _searchPattern(self,node,word,indx,pattern,output):
        if indx == len(pattern):
            if node.word_ending :
                output.append("".join(word))
            return
        if node.children.keys() == 0:
            return
        if pattern[indx] != '.' and   pattern[indx] !=  '*' :
            for ch in node.children.keys():
                if ch == pattern[indx]:
                    word.append(ch)
                    self._searchPattern(node.children[ch],word,indx+1,pattern,output)
        if pattern[indx] == '.':
            for ch in node.children.keys():
                word.append(ch)
                self._searchPattern(node.children[ch], word, indx + 1, pattern,output)
                word.pop()
        if pattern[indx] == '*':
            for ch in node.children.keys():
                if (pattern[indx-1] ==  "."):
                    if (pattern[indx+1] in node.children.keys()):
                        word.append(pattern[indx+1])
                        self._searchPattern(node.children[pattern[indx+1]], word, indx+1, pattern, output)
                        word.pop()
                    else:
                        word.append(pattern[indx + 1])
                        self._searchPattern(node.children[pattern[indx + 1]], word, indx, pattern, output)
                        word.pop()
                elif pattern[indx-1] == ch :
                    word.append(ch)
                    self._searchPattern(node.children[ch], word, indx, pattern, output)
                    word.pop()
                else:
                    self._searchPattern(node, word, indx+1, pattern, output)











#Create prefixes, get palindromes in the prefixes and look for their revered suffixes to form a palindrome
#get prefixes for a given word

def getPrefixList(word):
    pList = []
    for i in range(len(word)):
        pList.append(word[:i])
    return(pList)

def getSuffixList(word):
    sList = [word[i:] for i in range(len(word))]
    return(sList)

def isPalin(word):
    half_len = int(len(word)/2)
    sz = len(word)
    for i in range(half_len):
        if word[i] != word[sz-1-i]:
            return False
    return True

def reverse(s):
    str = ""
    for i in s:
        str = i + str
    return str

def computePair(wList):

    #Compute the Prefix tree for the dictionary
    wtrie = Trie()
    for li in range(len(wList)):
        wtrie.addword(wList[li])
    #Now take each word and get the Prefix List and
    #corresponding suffix list of the word,
    #For each pair  , if the prefix is a palindrome ,
    # reverse the suffix , look for the word
    palinList = []
    for word in wList:
        pList = getPrefixList(word)
        sList = getSuffixList(word)
        for i in range(len(pList)):
            if (isPalin(pList[i])):
                #reverse the corresponding suffix
                findStr= reverse(sList[i])
                if wtrie.searchword(findStr) :
                    palinList.append(findStr + word)
            if (isPalin(sList[i])):
                #reverse the corresponding prefix
                findStr= reverse(pList[i])
                if wtrie.searchword(findStr) :
                    palinList.append( word + findStr )
    print(palinList)
    return(palinList)


wordList = ["ape" ,"sdf", "abc", "cba", "pa"]
computePair(wordList)





