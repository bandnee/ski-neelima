1) Write  code in English  first before you start writing code
2) Amortized runtime
3) Asymptotic runtime analysis
4) serialization/deserialization
5) Recurrence relationships
6) F(n) : { 0 if n ==0
            1 if n ==1
           otherwise :  f(n-1) + f(n-2)
7) If an integer is prime or not
Sieve of Eratosthenes :
https://en.wikipedia.org/wiki/Generating_primes


8) If an integer is

Bullet points from Object Modeling
Type :can be of N types: is a contract or agreement

Class:Template,Reuse, visibility,encapsulation,inheritance,association

Object:

part-of: composition
is-a : inheritance

9)Class Structure 'vs' Object Structure

10)Design Pattern - Decorator , apply the constructor in layers

11)Hierarchy

12) Polymorphism

13 ) Object Persistence

14) Mantras
    -Always program to an interface and not to an implementation ( ArrayList al =new ArrayList )(not to rite way to use )
    - Always prefer object-based composition to class-based in-heritance
15) Use cases : Identify nouns and verbs


SOLID principleas for OO Design:
    - Single Responsibility Principle
    -Open/Close Principle
    - Polymorphism
    -Interface Segregation Principle
    -
16) Controller
17)Problems :
    Parking Lot
    Math Calculator
    Elevator
    Restaurant reservation system
    Elevator System for building having multiple elevators
    Design a FileSystem
18) Composite :
    Unification of interfaces(Proxy )
    Visitor
    abstract factory

19)Graphs:
adjacency lists : Every vertex is responsible for a  reference to it's neighbors.
adjacency Matrix:

20 ) Think of functions as questions ,makes it easy with recursion

##########     Scalable Systems     ##############
Problems :
1) #  of data rows (keys)
2) # of parallel requests
3) Geographically distributed usage
4) Single Point if failure
5) Data hotspot : Everyone is trying to access the same data
6) Service hotspot:
7)Cardinality

Solutions:        New Problems caused by solutions

1) Replication  - (4,5,3,6,2)  complexity,consistency
2) Sharding (1,2,4)
3) Array of App Servers (2,4,3,6)
4) Caching : Time line ( twitter), CDN(content delivery network)


Overall Design :
- Load Balancer: Software in the past/ Hardware right now   ( requests should be made stateless) is on the app side
- Data Center:
- Latency :
- Timestamp plays a key role
- LTP Protocol:
- Config Server : Keeps track of the sharding data.

1)  Define functional Requirments
    - Functional   - get/put , size of key/val,data_types,consistency of data
    - Capacity & Latency - SLI/SLO/SLA, QPS(Queries per Second ) of Reads, QPS (no of Writes: new keys->500 new keys/sec, key:updates->1000 updates/sec)


2) Storage Design: ( roughly u design a system of 3 years ):

500        *     100,000         *  1,000      * 6,00000
KVP/sec           sec/day            days/3yrs     1kvp

3PB of total

Logical Design
Physical Design
Indexing

- Sharding :
    key_size = 500 bytes
      S1    S2     S3      S4

    Distribution Policy:
     1)  mod 4 - Issues (adding new shards
              - One shard is down

     2) Hashing  -""

     3) Range based - capacity overflow ,uneven

    Industry Standard
    - Consistent Hashing:
    4) When 1 goes down , you have to bring up the


Replication:  CAP Theorem:

-Consistency
-Availability : Request should not fail
-Partition Tolerance : Distributed system should have network failure tolerance .
CA: Examples - Monolithic , Oracle Server,HP-nonstop { relational database }
AP: Redis/Cassandra/Mysql  Does not Fail ( stale is ok ) { }
CP: Quorum Write, Quorum Read ( Can fail, always,current)
pub-sub : Timestamp
3) Full Architecture of System


Logical Design:
    Relational -> Primary Key , Alternate keys
    Column Family: Primary Key, Column Family ( nextflix usecase)
Physical Design:
    Row Oriented : offset1:a1|x1|p1 :: offset2:a2|x2|p2
    Column Oriented :  Access patterns - A1|X1

Interface: -API
           -CLI
           -SQL
NOSQL : Not Only SQL ( Key/ value access)

Indexing:
        Hash Index : Primary Key
        B-tree Index
        Inverted Index


4) Micro Services Pattern :

5) Concurrency :

Locking: Can get it into deadlock.
Leasing: Is a lock with timeout

6)Caching :
    - freshness: - Write-through Cache  -  Cache +db
                 - Write-around  Cache  - dbonly (Cache later)
                 - Write-back - > cache only (db later)

    - Eviction :
    - Writes

7) Url Shortener:
Requirements:

* Given URL : return short URL

Pradeep

- Understand the first principles

Programming Python  Tricks :

# Initialize a 2D matrix of size n in python
board = [[0] * (n) for _ in range(n)]

# Initialize a