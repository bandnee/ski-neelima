Arrays:

---------- SHUFFLE ARRAY'S:  ---------

1: Definition: Contiguous collection of structures, each structure is of fixed length.
  - Random access
  - Logical linear address space

2: shuffle of an array - I have been given a set of integers, the shuffle API should return a shuffled array

{2,3,1,4,5} : is a n! permutations

shuffle(int* array, int n) : returns the original array.
-Since there are n! solutions , best algorithm should generate a result with a probability of
1/n! -> this gives uniform distribution .

We will need  a random number genertor rand(n): returns a value from 0 to n-1 with a prob of 1/n
1/n! = (1/n)*(1/n-1)*.....1

shuffle(int* arr, int n)
{
   for(int i = n-1, i>=0, i--)
   {
        int index = rand(i+1);
        swap(array[i],array[index]);
    }
}

------------ K-V Store : LinkedIn Question  -----------

CRUD operations: create/read/update/delete

PUT(K,V),DELETE(K),GET(K)

Haspmap is preferred in-memory structure: constant lookup , not necessarily O(1)  **** WHY ?****

GETRANDOM() -> This will return a random v from the k-V store again but under a uniformly distributed probability.

Auxiliary space is not a problem and is ok.

Questions for the interviewer:  What should be the frequency, which API's should take precendence.

All API's are equal priority: Use of auxiliary structures.
    - Ensure that you waste minimal space
    - Keep both structures in sync .
    - Mapping from primary to secondary as well as from secondary to primary

Hashmap as the primary, and array as a secondary srtucture :

Delete from the middle of the array: Swap with the end of the array and reduce the size of the array by 1

Berkely DB (append-only filesystem)
    Hashmap: <k,index>
    Array: [k,V]

Concurrency: New arrays , Dynamo DB

3:====== Retain Best Cache ======

    a. GET(k) will return value from the cache if it exists
    b. If not, it will read the <k,V> from an underlying data source, use V = DSGET(k);
    c. If the cache exceeds a certain size, then evict the lowest rank value from the cache
    d. We have API getRank(V) that gives the rank, rank is static
    e. Multiple <k,V>s can have the same rank.

Hashmap: is the primary structure -> GET constant order
Priority Queue - >  Finding min or max of an array in const order

Hashmap<K,V>
PQ <rank, set of <K>>  ( started with the
BST<rank,set of<K>> ( Optimizing for search )
track the minimum separately.

O(logn) n is the size of the Cache
O(r )-> r is the size of rank
O(logr) to delete the BST
GET(key K)


4: =========== Maxstack++ ===========

API's

1: Push(V); inserts an element to a list
2: Pop(): Delete and the return the last element inserted
3: Peek(): return the last element inserted
4: Peekmax(): Return the maximum element in the structure
5: Popmax(): Delete all the maximum elements in the structure

Link List and PQ:
TombStone Delete(For marking the deleted elements)
Skip Lists


5: =============== Event Logger System(KAFKA) =============

- CreateWindow(int maximum)
- addEvent(Event e)
- GET(int offset) -> returns an event at or the next higher offset
    a:Offsets are in size of 16KB

Constraints :

Circular Buffer:
- Auxiliary structure of the offsets

6: =============== Merge Overlapping Intervals ================

We have to implement 2 API's
1: insertInterval(int start, int end)
2: getMergedInterval()
Input:
[1,5],[10,15],[2,4][3,6]

output:
[1,6][10,15]

Sort by start times

[1,5],[2,4],[3,6]

[1,5][3,6][10,15]
[1,6][10,15]

Ask the interviewer questions about:

Option 1:
Favoring insert:O(1)
Get: nlogn

Option 2:
insert:Order(n)
Get:order(n)

//choose the middle ground

BST on concurrency stuff

Avial Tree

7: =========== Given an array of size n, find the maximum of each subarray of size k, k<=n ===========
{1,4,3,1,2,5,2,3,6} and k =3
{4,4,3,5,5,5,6} = n-k+1
A queue of size k
O(1) time for  getMax
4,3,2,1,0
   4,3,2
      3,2,1
        2,1,0


1,4,3,1,2

  1
     4
      4
      4

8: ==============   Majority Element  =====================

-  More than n/2 times
{1,2,3,3,3}

2) Sorted Array  -BST

Moore's voting algorithm

webscale ?
concurrency control ?




