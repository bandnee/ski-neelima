def quicksort(A,start,end):
    if start >= end:
        return

def Partition(A,start,end,pivotindex):
    boundary,j=start
    #Swap with the last element
    swap (A,pivotindex,end)
    while(j< end+1):
        if (A[j] <= A[end] ):
            if(j != boundary):
                swap(A[j],a[boundary])
            boundary = boundary+1
        j = j + 1
    #put the pivot position back in it's position.
    swap(A,boundary,end)
    return(boundary)


def Partition_M(A, start,end,pivotindex):
    i = start
    equal_boundary = start
    gt_begin = end
    for (i < gt_begin+1):
        if (A[i] < A[pivotindex]):
            if i != equal_boundary:
                A[i],A[equal_boundary] = A[equal_boundary],A[i]
            i = i + 1
            equal_boundary = equal_boundary +1
        elif (A[i] == A[pivotindex]):
            i = i + 1
        elif ( A[i] > A[pivotindex]):
            gt_begin = gt_begin -1
            A[i], A[gt_begin] = A[gt_begin], A[i]
    return (equal_bondary)





def quickSelect(A,k,start,end):
    pivotIndex = random.randint(start,end)
    finalIndex = Partition(A,start,end,pivotIndex)
    if finalIndex == k:
        return A[k]
    elif:
        finalIndex < k


Bonus Question:

A has odd length
A is oscillating

3<=5>=1<=10>=6
3 ,5 1,10,6
