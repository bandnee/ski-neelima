-Device Interop
-No Custom Ports
-HTTP as a transport
   Leverage status pattersn


Good REST API Design:
1) self-documentation, Readability
2) Leverage known  HTTP status code
3) Standard CRUD operations
    -GET
    -POST : Create a side effect
    -PUT :
    -DELETE :
    -PATCH : Partial Updates
    -OPTIONS : All the

 4)Versioning:
 api/v2/resource/v2
 5) Dev friendly
 6) Swagger : Tooling
 7) Companies -> company A
 8)https -channel| oauth -protocol
 9) Pagination:
 10)<HATEOAS Driven REST APIs>
 11) Asynchronous calls

 Amazon  Webservices:

 1) List Products
 2) View Producct
 3)view/read reviews for a product
 4) Post a new Review
 5) Update Review

 -List_of_lights: GET api/v1/list_products/lights #Got_the_result back with pagination
    Query TS :
    Last Record:

 -product: GET api/v1/get_product/List_of_lights[f1]
 -review_list:GET  api/vi/products/get_prod_reviews/List_of_lights[f1]
 -myreview: POST api/v1/post_review/List_of_lights[f1]
 -PUT api/v1/put_review/List_of_lights[f1].myreview

{
ADD
Update
Delete
}


Netfix:

DRM Agent
BIT Streaming Protocol
Microservices


Instagram:
Media Storage : outsourced

Fileservers:

readonly replica's :
Twitter-Snowflakes  ( global id generation)

Twitter:
Post -> Post

Top-/Trending Posts

Aggregate Query : Is a offline analytics engine  ( HDFS-  map/reduce )

Storm(Java)->Heron

UBer/Lyft
----------

Dispatch:
------------

Time_to_pickup: Attr.Matching ( uber-pool)
Driver Demographics
Geo-Spatial : S2cell id's
CellId = f(lat, lg)
[CellId] = g(CellId, radius)
Have direction






